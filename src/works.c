#include <stdio.h>

int n;
int k;
int A[100000];

// 1人の仕事量の上限をxで与えたとき，
// k人に配分しきれたときは1，
// 仕事が多くてk人に配分しきれないときは0を返す．
// これはxに対し単調増加となる．
int p(int x) {
	int k_req;	  // 今回必要になる人数
	int workload;	// 仕事をする人の個人の仕事量を計算するための変数
	int i = 0;		

	//各人に仕事量の上限であるxぎりぎりまでAの先頭から順番に仕事を割り振っていく
	for (k_req = 1; k_req <= k; k_req++) {
		workload = 0;
		while (workload + A[i] <= x) {
			workload += A[i];
			i++;
			//iがnに到達した場合，仕事をすべて割り振れているので1を返す．
			if (i == n)return 1;
		}
	}

	// --------------メモ---------------
	// k_reqについて，Aの要素にxを超えるものがあった場合，算出できず，
	// 際限なく増えていってしまい，ループが終わらない．
	// そのため，k_reqがkを超えた時点で，k_reqを増やすのをやめ，
	// 仕事を配分しきれないと判断して関数を終了する．
	// --------------------------------

	return 0;
}

int main() {
	int i, lb, ub;
	scanf("%d%d", &n, &k);
	for (i = 0; i < n; i++) {
		scanf("%d", &A[i]);
	}

	// A[i]のすべてが最小の1，かつk=nであった場合，
	// xは最小の1となる．
	// lbの初期値はその1つ小さい値を選択する．
	lb = 0;

	// A[i]がすべてが最大の10^4で，kが最小の1，nが最大の10^5であった場合，
	// xは最大の10^9となる．
	// ubの初期値はその1つ大きい値を選択する．
	ub = 1E+9 + 1;

	while (ub - lb > 1) {
		int mid = (lb + ub) / 2;
		if (p(mid)) {
			ub = mid;
		}
		else {
			lb = mid;
		}
	}

	//出力すべきなのはp(x)=1となる（＝仕事が配分しきれる）xの最小値
	printf("%d\n", ub);
	return 0;
}